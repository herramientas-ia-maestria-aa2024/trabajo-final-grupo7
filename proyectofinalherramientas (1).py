# -*- coding: utf-8 -*-
"""ProyectoFinalHerramientas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fvyEQqqPU8BggTUpYLcwAc3JoWVRfSNp
"""

# Importar librerias
import pandas as pd
import datetime

#instalar libreria para conectar a mi MySQL
!pip install mysql-connector-python
import mysql.connector

#ngrok tcp 3306

# Configura los detalles de conexión se requiere instalar ngrok
## Carga de datos desde la bdd MysQL database: personas
config = {
    'user': 'root',
    'password': 'root',
    'host': '0.tcp.sa.ngrok.io',
    'port':'17952',
    'database': 'personas',
    'raise_on_warnings': True
}

# Conectar a la base de datos
cnx = mysql.connector.connect(**config)
cursor = cnx.cursor()

# Realizar una consulta SQL
query = "SELECT * FROM personas.datospersona;"
cursor.execute(query)

# Cargar los datos en un DataFrame
df_partebdd= pd.DataFrame(cursor.fetchall(), columns=[i[0] for i in cursor.description])

# Cerrar la conexión
cursor.close()
cnx.close()

# Mostrar las primeras filas del DataFrame_parteBDD
print(df_partebdd.head())

## Carga de datos
!pip install Faker

from faker import Faker
import random
from datetime import datetime

fake = Faker()

# Lista de cédulas proporcionadas en el df_partebdd
cedulas = df_partebdd['cedula']

# Asegurarse de que la lista tiene 1000 elementos
#cedulas = cedulas * (1000 // len(cedulas) + 1)
#cedulas = cedulas[:1000]

# Generar los demás datos
data = {
    "cedula": cedulas,
    "nombre": [fake.first_name() for _ in range(1000)],
    "apellido": [fake.last_name() for _ in range(1000)],
    "direccion": [fake.address() for _ in range(1000)],
    "correo_electronico": [fake.email() for _ in range(1000)],
    "fecha_nacimiento": [fake.date_between(start_date=datetime(1970, 1, 1), end_date=datetime(1990, 12, 31)).strftime('%Y-%m-%d') for _ in range(1000)]
}

# trasnformar en csv datos de faker

df_partegenerada = pd.DataFrame(data)

# Mostrar las primeras filas del DataFrame para verificar
print(df_partegenerada.head())

# unir los dos dataframes el uno obtenido de MySQL y el otro generado con Facker
df_final = pd.merge(df_partebdd, df_partegenerada, on='cedula', how='inner')
print("\nInner Join:")
df_final.head()
numeroregistros= len(df_final)
print(numeroregistros)

# Verificar tipos de datos
def verificar_tipos(df_final):
    return df_final.dtypes
print(verificar_tipos(df_final))

# Convertir la columna 'fecha_nacimiento' y 'fechaingresoEmpresa' de objeto a datetime

df_final['fecha_nacimiento'] = pd.to_datetime(df_final['fecha_nacimiento'])
df_final.head()

df_final['fechaingresoEmpresa'] = pd.to_datetime(df_final['fechaingresoEmpresa'])
df_final.head()

print(verificar_tipos(df_final))

#Agregar una columna al datasetfinal  la columna Edad
from datetime import date
# definir una funcion que calcula la edad sabiendo la fecha actual y la fecha de nacimiento
def calcular_edad(nacimiento):
    hoy = date.today()
    return hoy.year - nacimiento.year - ((hoy.month, hoy.day) < (nacimiento.month, nacimiento.day))

# Aplicar la función para crear la columna de edad
df_final['edad'] = df_final['fecha_nacimiento'].apply(lambda x: calcular_edad(x))
df_final.head()

# crear un dicionario que especifique la provincia por la cedula
codigo_provincia = {
    '01': 'Azuay',
    '02': 'Bolivar',
    '03': 'Cañar',
    '04': 'Carchi',
    '05': 'Cotopaxi',
    '06': 'Chimborazo',
    '07': 'El Oro',
    '08': 'Esmeraldas',
    '09': 'Guayas',
    '10': 'Imbabura',
    '11': 'Loja',
    '12': 'Los Ríos',
    '13': 'Manabí',
    '14': 'Morona Santiago',
    '15': 'Napo',
    '16': 'Pastaza',
    '17': 'Pichincha',
    '18': 'Tungurahua',
    '19': 'Zamora Chinchipe',
    '20': 'Galápagos',
    '21': 'Sucumbíos',
    '22': 'Orellana',
    '23': 'Santo Domingo de los Tsáchilas',
    '24': 'Santa Elena'
}

#definir funcion que especifique a que provincia pertenece
def asignar_provincia(cedula):
    # Convertir a string y verificar si los primeros dos caracteres están en el diccionario
    cedula_str = str(cedula)
    codigo = cedula_str[:2]
    return codigo_provincia.get(codigo, 'Fuera del país')

# Aplicar la función para crear la columna 'provinciaNacimiento'
df_final['provinciaNacimiento'] = df_final['cedula'].apply(asignar_provincia)

# Mostrar el DataFrame resultante
print(df_final)

# Definicion de variable querealiza el conteo de personas en cada  provincia
conteo_provincias = df_final['provinciaNacimiento'].value_counts()
# Mostrar el conteo para verificar
print(conteo_provincias)

# Definicion de variable que realiza el conteo de personas por edad
conteo_porEdad = df_final['edad'].value_counts()
# Mostrar el conteo para verificar
print(conteo_porEdad)

#instalara libreria matplotlib para realizar las dos visualizaciones con esta libreria
!pip install matplotlib
import matplotlib.pyplot as plt

# Crear gráfico UNO de barras en la libreria matplotlib
plt.figure(figsize=(5, 4))  # Configura el tamaño del gráfico
conteo_porEdad.plot(kind='bar', color='skyblue')  # Gráfico de barras
plt.title('Cantidad de Personas por Edad')  # Título del gráfico
plt.xlabel('Edades')  # Etiqueta del eje X
plt.ylabel('Numero de Personas')  # Etiqueta del eje Y
plt.xticks(rotation=45, ha='right')  # Rotar las etiquetas del eje X para mejor lectura
plt.tight_layout()  # Ajusta automáticamente los parámetros del subplot para que el subplot se ajuste al área del gráfico

# Mostrar el gráfico
plt.show()

# Crear gráfico UNO de PASTEL en la libreria matplotlib
labels = conteo_provincias.index  # Las etiquetas son los nombres de las provincias
sizes = conteo_provincias.values  # Los tamaños son el conteo de cédulas en cada provincia

# Crear el gráfico de pastel
plt.figure(figsize=(5, 4))  # Configurar el tamaño de la figura
plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=140, colors=plt.cm.Paired.colors)  # Crear el pastel
plt.title('Cantidad de Personas por Provincia')  # Título del gráfico
plt.axis('equal')  # Esto asegura que el pastel se dibuje como un círculo.

# Mostrar el gráfico
plt.show()

#instalara libreria bokeh para realizar las dos visualizaciones con esta libreria
!pip install bokeh

# Crear grafico mediante bokeh
# Convertir a DataFrame para facilitar el manejo con Bokeh de # de personas en cada Povincia
conteo_df = conteo_provincias.reset_index()
conteo_df.columns = ['Provincia', 'Conteo']

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource
from bokeh.palettes import Category20  # Importar una paleta de colores adecuada


output_notebook()  # Para mostrar el gráfico dentro de Colab
print (conteo_df)
# Crear ColumnDataSource
source = ColumnDataSource(data=conteo_df)

# Crear la figura
p = figure(x_range=conteo_df['Provincia'], height=400, title="Conteo de Personas por Provincia",
           toolbar_location=None, tools="")

# Agregar las barras verticales
p.vbar(x='Provincia', top='Conteo', width=0.9, source=source,
       line_color='white', fill_color='navy')

# Personalizar el gráfico
p.xgrid.grid_line_color = None
p.y_range.start = 0
p.xaxis.major_label_orientation = 1.57  # Rotar las etiquetas para mejor visibilidad
p.outline_line_color = None

# Mostrar el gráfico
show(p)

#definiendo un dataframe que solo tenga los campos Edades y el total de personas en cada edad
conteo_df = conteo_porEdad.reset_index()
conteo_df.columns = ['Edades', 'Total']
print(conteo_df)
print(len(conteo_df))

# juntar registros comunes para solo tener un dataframe de 20 registros
# Ordenar el DataFrame por 'Edades'
conteo_df.sort_values('Edades', inplace=True)

# Combinar los dos últimos registros
new_row = pd.DataFrame({
    'Edades': [f"{conteo_df.iloc[-2, 0]}-{conteo_df.iloc[-1, 0]}"],
    'Total': [conteo_df.iloc[-2, 1] + conteo_df.iloc[-1, 1]]
})

# Eliminar los dos últimos registros y añadir el nuevo usando pd.concat
conteo_df = pd.concat([conteo_df.iloc[:-2], new_row]).reset_index(drop=True)

# Ejemplo de combinar otro par de registros para alcanzar 20 registros total
new_row_2 = pd.DataFrame({
    'Edades': [f"{conteo_df.iloc[0, 0]}-{conteo_df.iloc[1, 0]}"],
    'Total': [conteo_df.iloc[0, 1] + conteo_df.iloc[1, 1]]
})

conteo_df = pd.concat([conteo_df.iloc[2:], new_row_2]).sort_values('Total', ascending=False).reset_index(drop=True)

print(conteo_df)

from math import pi
from bokeh.io import show, output_notebook
from bokeh.plotting import figure
from bokeh.transform import cumsum
from bokeh.palettes import Category20c  # Esta paleta tiene 20 colores, necesitaremos más colores
from bokeh.models import ColumnDataSource

output_notebook()
df = pd.DataFrame(conteo_df)

# Asegurarte de que las edades están en string si son necesarias como etiquetas
df['Edades'] = df['Edades'].astype(str)

# Calcular los ángulos y porcentajes para el gráfico de pastel
df['angle'] = df['Total']/df['Total'].sum() * 2*pi
df['color'] = Category20c[20] * (len(df) // 20 )  # Repetir la paleta para tener suficientes colores
df['percentage'] = df['Total']/df['Total'].sum() * 100

source = ColumnDataSource(df)
p = figure(height=450, title="Distribución de Personas por Edad", toolbar_location=None,
           tools="hover", tooltips="@Edades: @Total (@percentage{0.2f}%)", x_range=(-1, 1))

p.wedge(x=0, y=1, radius=0.7,
        start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
        line_color="white", fill_color='color', legend_field='Edades', source=source)

p.axis.axis_label = None
p.axis.visible = False
p.grid.grid_line_color = None

# Mover la leyenda fuera del gráfico
p.legend.location = "top_left"
p.legend.label_text_font_size = "9px"

show(p)

#instalar la libreria pygwalker
!pip install pygwalker

#definiendo un dataframe que solo tenga los campos Provincia y el total de personas en cada provincia
conteo_df = conteo_provincias.reset_index()
conteo_df.columns = ['Provincia', 'Conteo']

#importando la libreria y llamando al objeto visual
import pygwalker as pyg
pyg.walk(conteo_df)

#definiendo un dataframe que solo tenga los campos Edades y el total de personas en cada edad
conteo_df = conteo_porEdad.reset_index()
conteo_df.columns = ['Edades', 'Total']
print(conteo_df)
pyg.walk(conteo_df)

# para obtener el DatasetFinal
df_final.to_csv('datasetFinal.csv', index=False)